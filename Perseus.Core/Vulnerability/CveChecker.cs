using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Perseus.Common.Models;

namespace Perseus.Core.Vulnerability
{
    public class CveChecker
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<CveChecker>? _logger;
        private readonly Dictionary<string, List<CveInfo>> _cveCache;

        public CveChecker(HttpClient? httpClient = null, ILogger<CveChecker>? logger = null)
        {
            _httpClient = httpClient ?? new HttpClient();
            _logger = logger;
            _cveCache = new Dictionary<string, List<CveInfo>>();
            
            // Configure HTTP client
            _httpClient.DefaultRequestHeaders.Add("User-Agent", "Perseus-Security-Scanner/1.0");
            _httpClient.Timeout = TimeSpan.FromSeconds(30);
        }

        public async Task<List<VulnerabilityResult>> CheckVulnerabilitiesAsync(
            List<ServiceResult> services,
            CancellationToken cancellationToken = default,
            double minimumCvssScore = 0.0)
        {
            var vulnerabilities = new List<VulnerabilityResult>();

            _logger?.LogInformation("Iniciando verificação de vulnerabilidades para {ServiceCount} serviços", services.Count);

            foreach (var service in services)
            {
                if (cancellationToken.IsCancellationRequested)
                    break;

                try
                {
                    var serviceCves = await GetCvesForServiceAsync(service, cancellationToken);
                    var filteredCves = serviceCves.Where(cve => cve.CvssScore >= minimumCvssScore).ToList();
                    
                    foreach (var cve in filteredCves)
                    {
                        var vulnerability = new VulnerabilityResult
                        {
                            CveId = cve.Id,
                            Title = cve.Summary,
                            Description = cve.Description,
                            CvssScore = cve.CvssScore,
                            Severity = GetSeverityFromCvss(cve.CvssScore),
                            AffectedService = $"{service.Name} {service.Version}",
                            Solution = cve.Solution,
                            References = cve.References,
                            IsExploitable = cve.HasExploit
                        };
                        
                        vulnerabilities.Add(vulnerability);
                    }

                    _logger?.LogDebug("Encontradas {CveCount} vulnerabilidades para {ServiceName}", 
                        filteredCves.Count, service.Name);
                }
                catch (Exception ex)
                {
                    _logger?.LogWarning("Erro ao verificar vulnerabilidades para {ServiceName}: {Error}", 
                        service.Name, ex.Message);
                }
            }

            // Sort by CVSS score (highest first)
            vulnerabilities.Sort((a, b) => b.CvssScore.CompareTo(a.CvssScore));

            _logger?.LogInformation("Verificação concluída. {VulnCount} vulnerabilidades encontradas", vulnerabilities.Count);
            
            return vulnerabilities;
        }

        private async Task<List<CveInfo>> GetCvesForServiceAsync(ServiceResult service, CancellationToken cancellationToken)
        {
            var cacheKey = $"{service.Name}_{service.Version}";
            
            if (_cveCache.TryGetValue(cacheKey, out var cachedCves))
            {
                return cachedCves;
            }

            var cves = new List<CveInfo>();

            try
            {
                // Try multiple CVE sources
                var nvdCves = await QueryNvdAsync(service, cancellationToken);
                cves.AddRange(nvdCves);

                // Add local CVE database queries here if available
                var localCves = GetLocalCves(service);
                cves.AddRange(localCves);

                // Cache the results
                _cveCache[cacheKey] = cves;
            }
            catch (Exception ex)
            {
                _logger?.LogWarning("Erro ao buscar CVEs para {ServiceName}: {Error}", service.Name, ex.Message);
            }

            return cves;
        }

        private async Task<List<CveInfo>> QueryNvdAsync(ServiceResult service, CancellationToken cancellationToken)
        {
            var cves = new List<CveInfo>();

            try
            {
                // NVD API 2.0 endpoint
                var searchTerm = Uri.EscapeDataString($"{service.Name} {service.Version}");
                var url = $"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={searchTerm}&resultsPerPage=50";

                var response = await _httpClient.GetAsync(url, cancellationToken);
                if (response.IsSuccessStatusCode)
                {
                    var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
                    var nvdResponse = JsonSerializer.Deserialize<NvdResponse>(jsonContent);

                    if (nvdResponse?.Vulnerabilities != null)
                    {
                        foreach (var vuln in nvdResponse.Vulnerabilities)
                        {
                            var cve = vuln.Cve;
                            if (cve != null)
                            {
                                var cveInfo = new CveInfo
                                {
                                    Id = cve.Id ?? "Unknown",
                                    Summary = cve.Descriptions?.FirstOrDefault()?.Value ?? "No description available",
                                    Description = cve.Descriptions?.FirstOrDefault()?.Value ?? "No description available",
                                    CvssScore = ExtractCvssScore(cve),
                                    PublishedDate = cve.Published ?? DateTime.MinValue,
                                    References = ExtractReferences(cve),
                                    HasExploit = CheckForExploit(cve)
                                };

                                cves.Add(cveInfo);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger?.LogWarning("Erro ao consultar NVD para {ServiceName}: {Error}", service.Name, ex.Message);
            }

            return cves;
        }

        private List<CveInfo> GetLocalCves(ServiceResult service)
        {
            // This would contain a local database of CVEs
            // For now, return some common vulnerabilities based on service type
            var cves = new List<CveInfo>();

            var serviceName = service.Name.ToLower();

            // Add some common vulnerabilities based on service type
            if (serviceName.Contains("apache"))
            {
                cves.AddRange(GetApacheCves(service.Version));
            }
            else if (serviceName.Contains("nginx"))
            {
                cves.AddRange(GetNginxCves(service.Version));
            }
            else if (serviceName.Contains("openssh"))
            {
                cves.AddRange(GetOpenSshCves(service.Version));
            }
            else if (serviceName.Contains("mysql"))
            {
                cves.AddRange(GetMySqlCves(service.Version));
            }

            return cves;
        }

        private List<CveInfo> GetApacheCves(string? version)
        {
            var cves = new List<CveInfo>();

            // Example Apache CVEs (this would be populated from a real database)
            if (string.IsNullOrEmpty(version) || IsVersionVulnerable(version, "2.4.49"))
            {
                cves.Add(new CveInfo
                {
                    Id = "CVE-2021-41773",
                    Summary = "Apache HTTP Server 2.4.49 Path Traversal",
                    Description = "A flaw was found in a change made to path normalization in Apache HTTP Server 2.4.49.",
                    CvssScore = 7.5,
                    HasExploit = true,
                    References = new List<string> { "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41773" }
                });
            }

            return cves;
        }

        private List<CveInfo> GetNginxCves(string? version)
        {
            var cves = new List<CveInfo>();

            if (string.IsNullOrEmpty(version) || IsVersionVulnerable(version, "1.20.1"))
            {
                cves.Add(new CveInfo
                {
                    Id = "CVE-2021-23017",
                    Summary = "Nginx DNS Resolver Off-by-One Heap Write",
                    Description = "A security issue in nginx resolver was identified, which might allow an attacker who is able to forge UDP packets from the DNS server.",
                    CvssScore = 8.1,
                    HasExploit = false,
                    References = new List<string> { "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23017" }
                });
            }

            return cves;
        }

        private List<CveInfo> GetOpenSshCves(string? version)
        {
            var cves = new List<CveInfo>();

            if (string.IsNullOrEmpty(version) || IsVersionVulnerable(version, "8.5"))
            {
                cves.Add(new CveInfo
                {
                    Id = "CVE-2021-41617",
                    Summary = "OpenSSH Privilege Escalation",
                    Description = "sshd in OpenSSH 6.2 through 8.x before 8.8 allows privilege escalation.",
                    CvssScore = 7.0,
                    HasExploit = true,
                    References = new List<string> { "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41617" }
                });
            }

            return cves;
        }

        private List<CveInfo> GetMySqlCves(string? version)
        {
            var cves = new List<CveInfo>();

            if (string.IsNullOrEmpty(version) || IsVersionVulnerable(version, "8.0.27"))
            {
                cves.Add(new CveInfo
                {
                    Id = "CVE-2022-21245",
                    Summary = "MySQL Server Information Disclosure",
                    Description = "Vulnerability in the MySQL Server product allows low privileged attacker with network access to compromise MySQL Server.",
                    CvssScore = 6.5,
                    HasExploit = false,
                    References = new List<string> { "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-21245" }
                });
            }

            return cves;
        }

        private bool IsVersionVulnerable(string currentVersion, string vulnerableVersion)
        {
            // Simple version comparison (this should be more sophisticated in production)
            try
            {
                var current = new Version(currentVersion);
                var vulnerable = new Version(vulnerableVersion);
                return current <= vulnerable;
            }
            catch
            {
                return true; // Assume vulnerable if we can't parse versions
            }
        }

        private double ExtractCvssScore(dynamic cve)
        {
            try
            {
                // Try to extract CVSS score from various possible locations in the CVE data
                if (cve.Metrics?.CvssMetricV31 != null && cve.Metrics.CvssMetricV31.Count > 0)
                {
                    return (double)(cve.Metrics.CvssMetricV31[0].CvssData?.BaseScore ?? 0.0);
                }
                if (cve.Metrics?.CvssMetricV30 != null && cve.Metrics.CvssMetricV30.Count > 0)
                {
                    return (double)(cve.Metrics.CvssMetricV30[0].CvssData?.BaseScore ?? 0.0);
                }
                if (cve.Metrics?.CvssMetricV2 != null && cve.Metrics.CvssMetricV2.Count > 0)
                {
                    return (double)(cve.Metrics.CvssMetricV2[0].CvssData?.BaseScore ?? 0.0);
                }
            }
            catch
            {
                // Ignore parsing errors
            }
            
            return 0.0;
        }

        private List<string> ExtractReferences(dynamic cve)
        {
            var references = new List<string>();
            
            try
            {
                if (cve.References != null)
                {
                    foreach (var reference in cve.References)
                    {
                        if (reference.Url != null)
                        {
                            references.Add(reference.Url.ToString());
                        }
                    }
                }
            }
            catch
            {
                // Ignore parsing errors
            }
            
            return references;
        }

        private bool CheckForExploit(dynamic cve)
        {
            // Simple heuristic to check if exploit might be available
            try
            {
                var description = cve.Descriptions?.FirstOrDefault()?.Value?.ToString()?.ToLower() ?? "";
                return description.Contains("exploit") || description.Contains("poc") || description.Contains("proof of concept");
            }
            catch
            {
                return false;
            }
        }

        private string GetSeverityFromCvss(double cvssScore)
        {
            return cvssScore switch
            {
                >= 9.0 => "Critical",
                >= 7.0 => "High",
                >= 4.0 => "Medium",
                >= 0.1 => "Low",
                _ => "None"
            };
        }

        public void Dispose()
        {
            _httpClient?.Dispose();
        }
    }

    // Data models for NVD API response
    public class NvdResponse
    {
        public List<VulnerabilityItem>? Vulnerabilities { get; set; }
    }

    public class VulnerabilityItem
    {
        public CveItem? Cve { get; set; }
    }

    public class CveItem
    {
        public string? Id { get; set; }
        public DateTime? Published { get; set; }
        public List<Description>? Descriptions { get; set; }
        public dynamic? Metrics { get; set; }
        public dynamic? References { get; set; }
    }

    public class Description
    {
        public string? Value { get; set; }
        public string? Lang { get; set; }
    }

    public class CveInfo
    {
        public string Id { get; set; } = string.Empty;
        public string Summary { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public double CvssScore { get; set; }
        public DateTime PublishedDate { get; set; }
        public List<string> References { get; set; } = new();
        public bool HasExploit { get; set; }
        public string? Solution { get; set; }
    }
}

